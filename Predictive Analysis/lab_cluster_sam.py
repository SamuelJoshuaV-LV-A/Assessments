# -*- coding: utf-8 -*-
"""Lab_cluster_sam.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tduazD_M1TttiloyEc9MPFq-H3ys2ijT
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import seaborn as sns

#Loading the data

df = pd.read_csv("/content/Credit Card Customer Data.csv")
df

#Checking for null values

df.isnull().sum()

#Using imputation to fill the missing value detected

from sklearn.impute import KNNImputer
num_cols = df.select_dtypes(include=['int64','float64']).columns

imputing = KNNImputer()
for i in num_cols:
  df[i] = imputing.fit_transform(df[[i]])

df.isnull().sum()

num_cols = df.select_dtypes(include=['int64','float64']).columns
num_cols

#Checking for duplicates - No duplicates found

df.duplicated().sum()

df.shape

#Removing outliers since there are few as noted in the box plot

Q1 = df[num_cols].quantile(0.25)
Q3 = df[num_cols].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
outlier = ((df[num_cols]<lower_bound )| (df[num_cols]>upper_bound)).any(axis=1)
df = df[~outlier]

#Comprehensive overview of data

df.describe(include='all')

#Box plot to check for univariate analysis and checking for the presence of outliers

for i in num_cols:
  sns.boxplot(df[i])
  plt.show()

for i in num_cols:
  sns.boxplot(df[i])
  plt.show()

#checking the number of rows after removing outliers

df.shape

#univariate analysis
numerical = df.select_dtypes(include=['number']).columns

for i in numerical:
  sns.histplot(df[i])
  plt.show()

#bivariate

num_cols = numerical = df.select_dtypes(include=['number']).columns
for i in range(len(num_cols)):
    for j in range(i + 1, len(num_cols)):
        plt.figure(figsize=(10, 6))
        sns.scatterplot(data=df, x=num_cols[i], y=num_cols[j])
        plt.title(f'Scatter Plot between {num_cols[i]} and {num_cols[j]}')
        plt.show()

#Understanding correlation between variables in the data for bivaraiate analysis and feature selection

df[numerical].corr()

sns.heatmap(df[numerical].corr(),annot=True,cmap='coolwarm',fmt=".2f")

df.nunique()

#Feature Selection (engineering) - Dropping columns with lots of nique values and no correlation whatsoever
#Here Sl_No and Customer Key are Unique ID columns that do not have predictive power
# Dropping Unique ID columns because they do not provide meaningful information about the patterns or relationships in the data.
# They have high cardinality and lots of unique values
#Segmenting customers based on these ID columns make no business sense either

df = df.drop(columns=['Sl_No','Customer Key'])
df

#Data type check
df.dtypes

#Encoding the categorical variables is needed because most machine learning algorithms cannot handle categorical data directly and require numerical input
#There is no need for encoding here since all columns have numerical datatype

#Scaling is done for better optimization

scaling = StandardScaler()
scaled_data = scaling.fit_transform(df)

scaled_data

#Determining the optimal number of clusters (k) using elbow method

elbow=[]
silhouette_scores = []
k_values = range(2, 10)
for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(scaled_data)
    elbow.append(kmeans.inertia_)
    silhouette_scores.append(silhouette_score(scaled_data, kmeans.labels_))

plt.plot(k_values, elbow, marker='o')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia(WCSS)')
plt.title('Elbow Curve for Optimal k')
plt.xticks(k_values)
plt.show()

optimal_k = 3 #from the eblow point in the plot

# fit the KMeans model with this optimal k value

kmeans = KMeans(n_clusters=optimal_k, random_state=42)
kmeans.fit(scaled_data)
cluster_labels = kmeans.predict(scaled_data)

# Check how similar an object is to its own cluster compared to other clusters using shilhouette score

#silhouette = silhouette_score(scaled_data, cluster_labels)
print('Silhouette score is found to be: ', silhouette_score(scaled_data, cluster_labels))

#Cluster Profiling to understand each cluster
df['Cluster'] = kmeans.labels_

cluster_profiles = df.groupby('Cluster').mean()
print(cluster_profiles)

# Business insight

# Cluster 0:

# Customers in this cluster have the highest average credit limit, suggesting they might have a higher creditworthiness.
# They also have the highest number of credit cards and make the most visits to the bank.

#Business Recommendation for cluster 0:

# This cluster could be targeted with premium credit card offers or other financial products that cater to high-value customers.

# Business insight

# Cluster 1:
# Customers in this cluster have the lowest average credit limit and the fewest number of credit cards.
# They also make the fewest visits to the bank and online.

#Business recommendation for cluster 1:

# This cluster could be targeted with entry-level credit card offers or other financial products that are designed for customers with limited credit history.

#Business insight for cluster 2:

# Customers in this cluster have an average credit limit and number of credit cards that falls between the other two clusters.
# They also make a moderate number of visits to the bank.

#Business recommendation for cluster 2:

#This cluster could be targeted with a variety of credit card offers and other financial products that are tailored to their specific needs.

#Scatter plot to understanding the effective clustering done

plt.figure(figsize=(8, 6))
plt.scatter(scaled_data[:, 0], scaled_data[:, 1], c=cluster_labels, cmap='viridis', s=50, alpha=0.5)
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('KMeans Clustering')

# Plotting centroids

plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], marker='o', c='red', s=200, label='Centroids')
plt.legend()
plt.colorbar(label='Cluster')
plt.show()

print(kmeans.cluster_centers_)
#Returns a two-dimensional Numpy array which consists of coordinates of centres for the clusters

# Plotting with respect to Average Credit Limit and Visits to bank

df1 = df[df.Cluster==0]
df2 = df[df.Cluster==1]
df3 = df[df.Cluster==2]

plt.scatter(df1.Avg_Credit_Limit,df1['Total_visits_bank'],color='green')
plt.scatter(df2.Avg_Credit_Limit,df2['Total_visits_bank'],color='red')
plt.scatter(df3.Avg_Credit_Limit,df3['Total_visits_bank'],color='black')
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1],color='purple',marker='*',label='centroid')

plt.xlabel('Average Credit Limit')
plt.ylabel('Visits to bank')
plt.legend()

#Plotting with respect to Average Credit Limit and Visits to online

df1 = df[df.Cluster==0]
df2 = df[df.Cluster==1]
df3 = df[df.Cluster==2]

plt.scatter(df1.Avg_Credit_Limit,df1['Total_visits_online'],color='green')
plt.scatter(df2.Avg_Credit_Limit,df2['Total_visits_online'],color='red')
plt.scatter(df3.Avg_Credit_Limit,df3['Total_visits_online'],color='black')
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1],color='purple',marker='*',label='centroid')

plt.xlabel('Average Credit Limit')
plt.ylabel('Visits to online')
plt.legend()

#Plotting with respect to Total credit cards and Visits to bank

df1 = df[df.Cluster==0]
df2 = df[df.Cluster==1]
df3 = df[df.Cluster==2]

plt.scatter(df1.Total_Credit_Cards,df1['Total_visits_bank'],color='green')
plt.scatter(df2.Total_Credit_Cards,df2['Total_visits_bank'],color='red')
plt.scatter(df3.Total_Credit_Cards,df3['Total_visits_bank'],color='black')
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1],color='purple',marker='*',label='centroid')

plt.xlabel('Credit cards available')
plt.ylabel('Visits to bank')
plt.legend()

#Business takeaway

# Customers can be segmented into high-value, entry-level, and moderate based on average credit limit, total credit cards, and total visits to account.

# Business Implication: Target marketing campaigns and product offerings to each segment for increased customer satisfaction.

# Business understanding:

# High credit limit and number of cards correlate with more visits to banking services, indicating active financial management.

# Low credit limit and few cards suggest limited banking needs, resulting in fewer visits.

# Medium levels reflect balanced financial behavior and moderate visit frequency.